import osimport copyimport astimport nrrdimport pandas as pdimport numpy as npimport pydicom as dcmimport matplotlib.pyplot as pltfrom matplotlib.widgets import Buttonfrom matplotlib.patches import Circleclass ButtonFunction:    def save(self, event):        self.path = 'good_crop'        plt.close()    def discard(self, event):        self.path = 'bad_crop'        plt.close()    def maybe_save(self, event):        self.path = 'maybe_crop'        plt.close()    def inverted_save(self, event):        self.path = 'inverted'        plt.close()def create_crop_subDir(target_PG, uid):    if not os.path.exists(target_PG):        os.mkdir(target_PG)        # sub dir    if not os.path.exists(os.path.join(target_PG, uid)):        os.mkdir(os.path.join(target_PG, uid))def get_pg_and_id(line):    split_line = line.split('/')    split_line[5] = split_line[5][:-1]    return split_line[4], split_line[5]def get_x_y_delta(keypoints):    x = (keypoints['X'] - keypoints['Scala'])#centro meno raggio    y = (keypoints['Y'] - keypoints['Scala'])    delta = keypoints['Scala'] * 2    return x, y, deltadef create_dirty_parts(keypoints):    x, y, delta = get_x_y_delta(keypoints)    dirty_parts = [int(y), int(y + delta), int(x), int(x + delta)]    return  dirty_partsdef normalize_parts(parts, dcm_shape):    # parts AKA [y, y + delta, x, x + delta]    square_flag = True    if parts[1] > dcm_shape[0]:        parts[1] = dcm_shape[0]        square_flag = False    if parts[3] > dcm_shape[1]:        parts[3] = dcm_shape[1]        square_flag = False    for j in range(len(parts)):        if parts[j] < 0:            square_flag = False            parts[j] = 0    return parts, square_flagbirads = input('inserire birads:  1  || 3 || 4:  ')dicom_path_file = open(f"dataset/path_dicom_originali/birads{birads}.csv", 'r')database_def = '/Volumes/LAB/DBDefinitivo'final_dataset = pd.read_csv(r"dataset/path_dicom_originali/final.csv", sep=';', dtype='str')destination_crop_path = r'dataset/crop_mask/' + f'crop_birads{birads}_supervisonato'error_CROP_list = []error_ROI_list = []count_path = 1not_square_list = []callback = ButtonFunction()##################################for line in dicom_path_file:    pg, uid = get_pg_and_id(line)    index = final_dataset[final_dataset['UID'] == uid].index.values    keypoints = ast.literal_eval(final_dataset.iloc[index[0]][3])    dicom = dcm.read_file(line[:-1])    print(pg, uid, 'index in final.csv: ', index[0], 'cartella:', count_path)    for i in range(len(keypoints)):        good_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/good_file_list.csv', 'a')        bad_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/bad_file_list.csv', 'a')        maybe_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/maybe_file_list.csv', 'a')        inverted_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/inverted_file_list.csv', 'a')        error_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/error_file_list.csv', 'a')        not_square_file = open(f'dataset/crop_mask/crop_birads{birads}_supervisonato/not_square_file_list.csv', 'a')        deep_crop = copy.deepcopy(dicom)        deep_roi = copy.deepcopy(dicom)        #CROP        try:            dirty_parts = create_dirty_parts(keypoints[i])            parts, square_flag = normalize_parts(dirty_parts, dicom.pixel_array.shape)            deep_crop.PixelData = deep_crop.pixel_array[parts[0]:parts[1], parts[2]:parts[3]].tobytes()            deep_crop.Rows = parts[1] - parts[0]            deep_crop.Columns = parts[3] - parts[2]            #GRAFICO            fig, axs = plt.subplots(1, 2, figsize=(15,10))            axs[0].imshow(dicom.pixel_array, cmap=plt.cm.bone)            axs[1].imshow(deep_crop.pixel_array, cmap=plt.cm.bone)                #original dicom            axs[0].format_coord = lambda x, y: f"x={x:.2f}, y={y:.2f}"            axs[0].set_title(f'paziente: {pg},\n'                             f' vista:\n{uid[:]}')            axs[0].add_patch(Circle((int(keypoints[0]['X']), int(keypoints[0]['Y'])), int(keypoints[0]['Scala']), fill=False, color="red"))                #crop            axs[1].format_coord = lambda x, y: f"x={x:.2f}, y={y:.2f}"            axs[1].set_title(f'centro e raggio:\n{keypoints[i]}'                             f'\nporzioni di immagine:\n{parts}'                             f'\nindex of keypoint: {i}')            # button            ax_discard = plt.axes([0.53, 0.05, 0.1, 0.075])            ax_save = plt.axes([0.64, 0.05, 0.1, 0.075])            ax_maybe = plt.axes([0.75, 0.05, 0.1, 0.075])            ax_inverted = plt.axes([0.86, 0.05, 0.1, 0.075])            button_discard = Button(ax_discard, 'DISCARD')            button_discard.on_clicked(callback.discard)            button_save = Button(ax_save, 'SAVE')            button_save.on_clicked(callback.save)            button_maybe = Button(ax_maybe, 'MAYBE')            button_maybe.on_clicked(callback.maybe_save)            button_inverted = Button(ax_inverted, 'INVERT')            button_inverted.on_clicked(callback.inverted_save)            plt.show()            #check cartella finale            target_PG = os.path.join(destination_crop_path, callback.path,  pg)            create_crop_subDir(target_PG, uid)            save_name = f'crop_{i}.nrrd'            nrrd.write(os.path.join(target_PG, uid, save_name), deep_crop.pixel_array)            if callback.path == 'good_crop':                good_file.write(os.path.join(target_PG, uid, save_name)+',')            elif callback.path == 'bad_crop':                bad_file.write(os.path.join(target_PG, uid, save_name)+',')            elif callback.path == 'maybe_crop':                maybe_file.write(os.path.join(target_PG, uid, save_name)+',')            elif callback.path == 'inverted':                inverted_file.write(os.path.join(target_PG, uid, save_name)+',')            # scrive crop_path, la virgola perche aspetto la roi            print(os.path.join(target_PG, uid, save_name) )            if not square_flag:                not_square_file.write(f'PG:{pg}, UID:{uid}, parts:{parts} ')        except ValueError as error:            print(f'VALUE ERROR: CROP', error)            error_file.write(os.path.join(pg,uid)+'\t CROP ERROR')        #MASK        try:            arr = np.zeros((parts[1] - parts[0], parts[3] - parts[2]), dtype=np.uint16)            arr.fill(1)            arr[0, 0] = 0            deep_roi.PixelData = arr.tobytes()            deep_roi.Rows = parts[1] - parts[0]            deep_roi.Columns = parts[3] - parts[2]            save_name = f'roi_{i}.nrrd'            nrrd.write(os.path.join(target_PG, uid, save_name), deep_roi.pixel_array)            if callback.path == 'good_crop':                good_file.write(os.path.join(target_PG, uid, save_name)+'\n')                print('good crop')            elif callback.path == 'bad_crop':                bad_file.write(os.path.join(target_PG, uid, save_name)+'\n')                print('bad crop')            elif callback.path == 'maybe_crop':                print('maybe crop')                maybe_file.write(os.path.join(target_PG, uid, save_name)+'\n')            elif callback.path == 'inverted':                inverted_file.write(os.path.join(target_PG, uid, save_name)+'\n')                print('inverted crop')            print(os.path.join(target_PG, uid, save_name), '\nsalvato')        except ValueError as error:            print(f'VALUE ERROR: ROI', error)            error_file.write(os.path.join(pg, uid) + '\t ROI ERROR')        good_file.close()        bad_file.close()        maybe_file.close()        inverted_file.close()        error_file.close()        not_square_file.close()count_path +=1error_file = open(f'dataset/crop_mask/value_error_{birads}_supervisionato.txt', 'w')for i in range(len(error_CROP_list)):    error_file.write(error_CROP_list[i]+ '\n')error_file.write('\n')for i in range(len(error_ROI_list)):    error_file.write(error_ROI_list[i]+ '\n')error_file.close()with open(f'dataset/crop_mask/not_square_list{birads}_supervisionato.txt', 'a') as file_not_square:    for i in range(len(not_square_list)):        file_not_square.write(not_square_list[i]+ '\n')